# [HV23.23] Roll your own RSA

## Introduction

Difficulty: 1337<br>
Author: cryze

Santa wrote his own script to encrypt his secrets with RSA. He got inspired from the windows login where you can specify a hint for your password, so he added a hint for his own software. This won't break the encryption, will it?

## Solution

Oh god oh f*ck, leet RSA, but with good chances, as the challenge was spontaneously submitted by `cryze`, so maybe it won't be all that hard.

There's some interesting stuff straight away, which tells us that `x` and `y` are between 0 and 1000 (inclusive):

```py
from secret import FLAG, x, y
# D = {x∈ℕ | 0 ≤ x ≤ 1000}
# D = {y∈ℕ | 0 ≤ y ≤ 1000}
```

We got the following output from a flag encryption:

```
abc_sum=1709262
N=143306145185651132108707685748692789834391223254420921250753369412889732941905250889012412570851623535344424483564532684976892052830348014035303355261052741504390590825455129003262581199117432362073303998908141781601553213103109295898711066542593102305069363965164592663322089299134520383469241654273153506653
e=65537
hint=-367367861727692900288480576510727681065028599304486950529865504611346573250755811691725216308460956865709134086848666413510519469962840879406666853346027105744846872125225171429488388383598931153062856414870036460329519241754646669265989077569377130467115317299086371406081342249967666782962173513369856861858058676451390037278311316937161756731165929187543148639994660265783994439168583858109082136915810219786390452412584110468513829455001689531028969430907046738225668834761412112885772525079903072777443223873041260072918891696459905352737195384116938142788776947705026132197185926344278041831047013477983297898344933372775972141179163010102537733004410775357501267841845321271140399200044741656474378808452920297777911527159803159582800816951547394087190043792625664885536154225227819735800442814065528155407746556297892931242208688533313054308779657788077807340045465701247210553988059519291363634253248268722975827616752514688291723712069675405995149499947239454505797412122124933836396842943540518521648803348207619354854290787969076059265170474203200482079680136404766877617679652611682327535174212016390608658107555103054183393719700027186913354158961245998591486268846852581402900857595817303811471853325463202817521164757
encrypted=72792762778232160989381071629769766489971170790967414271032682193723004039685063639675377805724567838635943988752706743932748347933013530918279285456553768626331874756049006544553546268049053833014940495217179504587162478219970564159885619559723778613379425375733026859684952880028997538045791748027936366062
```

I called the first line abc_sum because that's what it is, after seeding `random` with `y`, a choice is made and 3 integers are generated for `a, b and c`, this gives us the first attack vector for `y`; we can just use all values from `0` to `1000` and looks if `a+b+c == abc_sum`, which happens at `y=787`

```py
for test_y in range(1001):
    random.seed(test_y)
    grade = random.choice([2,3])
    a = random.randint(9999, 999999)
    b = random.randint(8888, 888888)
    c = random.randint(7777, 777777)

    if a+b+c == abc_sum:
        y = test_y
        print(f"[+] Found: y={y}")
        break
```

Now we have the polynomial function generated by the program, which is `509736*x^3 + 671618*x^2 + 527908*x + 165945`.

The next step is getting the `x`, which we can also brute-force, to do this, we can re-arrange some things:

```py
p**3 - q**8 + polynomial_function(x=x) = hint   | -polynomial_function(x=x)
p**3 - q**8 = hint - polynomial_function(x=x)   | substitute p = (N/q)
(N/q)**3 - q**8 = hint - polynomial_function(x=x)
```

This formula can now be easily solved by sage:

```py
solutions = solve((N/q)**3 - q**8 == hint - y_x(x=test_x), q, solution_dict=True)
```

We can check if a solution has been found and, if yes, we have `q`, which also means we can calculate the rest of the `RSA` variables.

```py
p = N // q
phi = (p - 1) * (q - 1)
d = inverse_mod(e, phi)
flag = pow(encrypted, d, N)
```

The entire script then looks like this in my case:

```py
from Crypto.Util.number import *
from sage.all import *
import random

abc_sum=1709262
N=143306145185651132108707685748692789834391223254420921250753369412889732941905250889012412570851623535344424483564532684976892052830348014035303355261052741504390590825455129003262581199117432362073303998908141781601553213103109295898711066542593102305069363965164592663322089299134520383469241654273153506653
e=65537
hint=-367367861727692900288480576510727681065028599304486950529865504611346573250755811691725216308460956865709134086848666413510519469962840879406666853346027105744846872125225171429488388383598931153062856414870036460329519241754646669265989077569377130467115317299086371406081342249967666782962173513369856861858058676451390037278311316937161756731165929187543148639994660265783994439168583858109082136915810219786390452412584110468513829455001689531028969430907046738225668834761412112885772525079903072777443223873041260072918891696459905352737195384116938142788776947705026132197185926344278041831047013477983297898344933372775972141179163010102537733004410775357501267841845321271140399200044741656474378808452920297777911527159803159582800816951547394087190043792625664885536154225227819735800442814065528155407746556297892931242208688533313054308779657788077807340045465701247210553988059519291363634253248268722975827616752514688291723712069675405995149499947239454505797412122124933836396842943540518521648803348207619354854290787969076059265170474203200482079680136404766877617679652611682327535174212016390608658107555103054183393719700027186913354158961245998591486268846852581402900857595817303811471853325463202817521164757
encrypted=72792762778232160989381071629769766489971170790967414271032682193723004039685063639675377805724567838635943988752706743932748347933013530918279285456553768626331874756049006544553546268049053833014940495217179504587162478219970564159885619559723778613379425375733026859684952880028997538045791748027936366062

def generate_polynomial_function(seed):
    x = SR.var("x")
    random.seed(seed)
    grade = random.choice([2,3])
    a = random.randint(9999, 999999)
    b = random.randint(8888, 888888)
    c = random.randint(7777, 777777)

    if grade == 2:
        y_x = a*x**2+b*x+c
    if grade == 3:
        d = random.randint(6666, 666666)
        y_x = a*x**3+b*x**2+c*x+d

    return y_x

for test_y in range(1001):
    random.seed(test_y)
    grade = random.choice([2,3])
    a = random.randint(9999, 999999)
    b = random.randint(8888, 888888)
    c = random.randint(7777, 777777)

    if a+b+c == abc_sum:
        y = test_y
        print(f"[+] Found: y={y}")
        break

y_x = generate_polynomial_function(y)

for test_x in range(1001):
    # solve for q because it's faster than solving for p
    q = var('q')
    solutions = solve((N/q)**3 - q**8 == hint - y_x(x=test_x), q, solution_dict=True)
    q_solution = solutions[0].get(q)
    if q_solution:
        q = int(q_solution)
        print(f"[+] Found: x={test_x}")
        print(f"[+] Found: q={q}")
        break

p = N // q
phi = (p - 1) * (q - 1)
d = inverse_mod(e, phi)
flag = pow(encrypted, d, N)
print(f'[+] Flag: {bytes.fromhex(hex(flag)[2:]).decode()}')
```

Letting the entire script run gives us the following output:

```
[+] Found: y=787
[+] y_x=509736*x^3 + 671618*x^2 + 527908*x + 165945
[+] Found: x=692
[+] Found: q=11766238441137316218698559717070508606046977055528210983326091441049009527090037271072944725167437804861554714103321826526867364254290450294447086896338759
[+] Flag: HV23{1t_w4s_4b0ut_t1m3_f0r_s0me_RSA_4g41n!}
```

Flag: `HV23{1t_w4s_4b0ut_t1m3_f0r_s0me_RSA_4g41n!}`